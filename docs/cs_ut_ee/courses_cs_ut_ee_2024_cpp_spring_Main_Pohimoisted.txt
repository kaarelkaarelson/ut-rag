<LINK>https://courses.cs.ut.ee/2024/cpp/spring/Main/Pohimoisted</LINK>
Programmeerimine keeles C++ - Kursused - Arvutiteaduse instituut Kursused 2023/24 kevad Programmeerimine keeles C++ (LTAT.03.025) EN Logi sisse Programmeerimine keeles C++ 2023/24 kevad Pealeht 1. Muutujad ja andmetüübid 2. Keele põhikonstruktsioonid I 3. Keele põhikonstruktsioonid II 4. Klass, struktuur, mallid 5. Dünaamiline mäluhaldus I 6. Dünaamiline mäluhaldus II 7. Kontrolltöö 1 Seitsmendal nädalal toimub 1. kontrolltöö 1. kontrolltöö näidis on Moodles 8. Dünaamiline mäluhaldus III 9. STL andmestruktuurid I 10. STL andmestruktuurid II 11. OOP I Klassid 12. OOP II Pärilus ja polümorfism 13. Erindite töötlemine 14. Täiendavad teemad 15. Kontrolltöö 2 Viieteistkümnendal nädalal toimub 2. kontrolltöö 16. Projekti esitlus Mõned viited - vajalikud kaaslased Vanad materjalid Juhendid Viited Sissejuhatus kursusesse Eessõna Selles kursuses eeldame, et üliõpilane on läbinud programmeerimise algkursuse (nt keele Python baasil). Seetõttu käsitletakse keelekonstruktsioonidest vaid olulisemaid aspekte. Antud kursus ei eelda programmeerimiskeele Java tundmist. NB! Palun kõigist vigadest ja ebatäpsustest, samuti ettepanekutest materjalide parandamiseks  kirjutada helle.hein@ut.ee . Õpiväljundid Pärast selle praktikumi läbimist üliõpilane oskab koostada, kompileerida ja käivitada väga elementaarseid C++ programme oskab nimetada mõned olulised erinevused C++ ja Pythoni vahel, eriti need, mis teda võivad edaspidi häirida teab keeles C++ kasutatavaid põhilisi andmetüüpe teab, et C++ programme tuleb kompileerida teab ja oskab kasutada bitikaupa operaatoreid oskab kasutada standardsisendit ja -väljundit lahendab oma kodused ülesanded iseseisvalt ja on nõus selle nimel ka vaeva nägema ei karda kaaslastelt ja õppejõult nõu küsida Sisukord 1. Keskkonna seadistamine 6. Muutujate initsialiseerimine 11. Bitikaupa operaatorid 2. Esimene programm 7. Andmetüübid 12. Võtmesõna const 3. Kompileerimine ja käivitamine 8. Avaldised 13. Standardsisend ja standardväljund 4. Kompileerimisest 9. Tüübiteisendused 14. Enesetestid 5. Muutujad ja andmetüübid 10. Võtmesõna auto Muutujad ja andmetüübid Esmatutvus C++-ga. Esimene programm. Kompileerimine. Sisend-väljund. Programmi struktuur. Muutujad ja andmetüübid. C++ vs Python (põhikonstruktsioonid). Keskkonna seadistamine C++ programmide loomiseks võib kasutada erinevaid keskkondi. Käesolevas kursuses kasutame koodi loomiseks Visual Studio Code ( https://code.visualstudio.com/ , vt installeerimisjuhendit) ja kompileerimiseks kompilaatorit gcc (vt installeerimisjuhendit).
Samuti on võimalik kasutada keskkonda Clion ( https://www.jetbrains.com/clion/ ), mille installeerimisel ei pea eraldi kompilaatori gcc pärast muretsema. CLion student litsentsi saab taotleda aadressil https://www.jetbrains.com/community/education/#students või https://education.github.com/pack Käesoleva materjali koostamisel on kasutatud graafilist keskkonda Clion ja kompileerimiseks käsku g++ . Standard ISO/IEC 14882 (2020) määrab nõuded programmeerimiskeele C++ implementeerimiseks. Kuidas erinevad kompilaatorid toetavad keele võimalusi, seda saab vaadata siit: https://en.cppreference.com/w/cpp/compiler_support Juhendite lingid keskkonna seadistamiseks Windows arvuti VSCode ja MSYS2 ülesseadmine (inglise keeles) https://code.visualstudio.com/docs/cpp/config-mingw MSYS2 lahenduse puhul on tarvis süsteemi keskkonnamuutujale (environment variable) Path lisada järgnevad failiteed (eeldusel, et vaikeinstall): C:\msys64\mingw64\bin, C:\msys64\ucrt64\bin ja C:\msys64\usr\bin. Linuxi masinal on järgmine käsk: sudo apt install build-essential C++ arendusvahendid Mac OS X jaoks (vanast kursusest) https://courses.cs.ut.ee/2023/cpp/spring/Main/WorkingWithOSX Esimene programm Loome tekstifaili, paneme nimeks esimene.cpp ja kopeerime sinna alljärgneva teksti // Minu esimene C++ programm 
#include <iostream>
using namespace std;

int main(){
  cout << "Tere, maailm!";
  return 0;
} Kompileerimine ja käivitamine Enne täitmist tuleb C++ programm teisendada täidetavaks programmifailiks (nt Windows korral .exe fail). See protsess koosneb üldjuhul kolmest osast: eelprotsessori ( preprocessor ) töö, kompileerimine ( compiling ) ja linkimine ( linking ). Kõiki tööetappe juhitakse kompilaatori parameetritega (sellest edaspidi). Graafilises töökeskkonnas (nt Clion ) püütakse neid etappe kasutaja eest varjata. Meie esimese programmi korral eraldi linkimiskäsku ei ole vaja ja kompileerimiseks sisestame käsurealt (nt Windowsi käsuviip, aktiivne peab olema kaust, kus asub esimene.cpp ) >g++ -std=c++20 esimene.cpp Selle tulemusena tekib käivitatav programm a.exe . Programmi käivitamiseks sisestame käsurealt >a.exe Tulemuseks on ekraanil Tere, Maailm! Kui soovime käivitatavale failile nime panna (nt esimene.exe ), siis lisame kompilaatorile -o ja faili nime: >g++ -std=c++20 esimene.cpp -o esimene Vaatame nüüd programmi lähemalt ühe rea kaupa // Minu esimene C++ programm 
#include <iostream>
using namespace std;

int main(){
    cout << "Tere, maailm!";
    return 0;
} Rida 1 // C++ kommentaarid rea lõpuni. Mitmerealine kommentaar tuleb paigutada /* ja */ vahele. Rida 2 #include <iostream> Käsk #include <iostream> annab kompilaatorile teada, et on vaja enne kompileerimist võtta kogu kood iostream päisefailist ja paigutada programmi. Päisefail iostream võimaldab kasutada  sisend/väljund voogu (nt lugeda klaviatuurilt cin ja väljastada ekraanile cout ). Päisefailide kaasamine programmis annab võimaluse kasutada juba varem valmiskirjutatud koodi. Rida 3 using namespace std; annab kompilaatorile teada, et kasutatakse "standard nimeruumi". Nimeruumid aitavad vältida konflikte suuremates programmides. Selle rea puudumisel tuleb rea 6 asemel kirjutada std::cout << "Tere, maailm!"; . Rida 4 on tühi, seda C++ kompilaator ignoreerib. Read 5-8 int main(){
...
    return 0;
} Defineeritakse funktsioon nimega main , mis tagastab täisarvu. Antud juhul tagastatakse arv 0 ( return 0; ), mis tähistab programmi töö edukat lõppu. Funktsiooni sisu on loogeliste sulgude sees ( {} ) ja iga käsk lõpeb semikooloniga ( ; ). Igas C++ programmis peab olema main funktsioon, kust programmi töö algab. NB! C++ keel on tõstutundlik , st main ja Main on erinevad funktsioonid. Rida 6 cout << "Tere, maailm!"; Ekraanile kuvamiseks saab kasutada standardväljundit cout , kuhu suunatakse info operaatori << abil. Kui jätame ära rea 3 (standardnimeruumi kasutamise), siis tuleb näidata nimeruum ilmutatult std::cout << "Tere, maailm!"; Väljundisse saab saata ka mitu infoühikut, nt cout << "Tere, maailm! " << "See on minu esimene C++ programm." << '\n'; Peale kompileerimist ja käivitamist on ekraanil Tere, maailm! See on minu esimene C++ programm. Käsu lõpus olev '\n' lõpetab rea ja järgmine väljund läheb uuele reale. Uuele reale viib ka käsk endl , kuid dokumendis Bjarne Stroustrup, Herb Sutter "C++ Core Guidelines", September 23, 2022 https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#c-core-guidelines soovitatakse käsku endl mitte kasutada, kuna see aeglustab programmi tööd. Selle asemel hakkame kasutama juba varem tuntud uuele reale mineku käsku '\n' . cout << "Tere, maailm! " << "See on minu esimene C++ programm.\n"; Kui Pythonis on funktsiooni sisu taandega eraldatud, siis C++ taanet ja reavahetusi ei nõua, küll on seda programmi loetavuse huvides väga soovitav ikkagi teha. Põhimõtteliselt on töötav ka järgmine main funktsioon: int main(){cout << "Tere, maailm!";return 0;} Selline programm on aga väga halvasti loetav. Kompileerimisest Programmide kompileerimise ja käivitamise mõistmiseks on oluline teada, kuidas C++ kompileerimine töötab. C++ lähtekoodi kompileerimine masinloetavaks koodiks koosneb järgmisest neljast protsessist: 1. Lähtekoodi eeltöötlus preprotsessori ( preprocessor ) poolt. Preprotsessori direktiivid on programmi koodis sisalduvad read, mille alguses on märk # . Preprotsessor töötleb direktiive enne kompileerimise algust. Näiteks, kui koodis on preprotsessori direktiiv #include , siis asendab ta selle faili sisuga, luues laiendatud lähtekoodifaili. 2. Lähtekoodi kompileerimine. Peale preprotsessori tööd kompileeritakse kood laiendatud lähtekoodifailideks platvormile sobivas keeles. 3. Objektkoodifailide ( .o ) kokkupanek. Laiendatud lähtekoodifailid teisendatakse objektikoodifailideks. Enamasti vaadeldakse lähtekoodi kompileerimist ja objektkoodifailide kokkupanekut ühe protsessina. 4. Objektikoodifailide linkimine käivitatava faili loomiseks. Objektikoodifailid lingitakse koos standardteegi ja muude teekide objektikoodifailidega kokku, et luua käivitatav fail, nt laiendiga .exe . Muutujad ja andmetüübid Programmeerimiskeeles C++ (erinevalt Pythonist) peab nii muutuja tüüp kui ka funktsiooni tagastustüüp olema ilmutatult määratud . Näiteks täisarvu tüüpi muutuja deklareerimiseks saame kasutada tüüpi int int arv; Kui tahame näiteks kasutada täisarvutüüpi muutujaid arv1 ja arv2 ning ujukomaarvu ujuarv , saame kasutada tüüpe int ja float . int arv1, arv2;
float ujuarv; Muutuja kirjeldamise hetkel on muutuja väärtus määramata, seda saab teha hiljem arv1 = 1;
arv2 = arv1 + 1;
ujuarv = 5.2; Muutuja kirjeldamist ja talle väärtuse määramist saab ühendada ja seda nimetatakse muutuja initsialiseerimiseks. Muutujate initsialiseerimine Programmeerimiskeeles C++ on võimalik muutujat initsialiseerida kolmel viisil C-tüüpi initsialiseerimine (päritud keelest C) int arv = 10; Avaldist int arv = 10; nimetatakse omistamislauseks ( assignment statement ) ja = omistamisoperaatoriks ( assignment operator ). C++ keeles kasutatakse ka teistes keeltes tuntud liitomistamisoperaatoreid ( compound assignment operators ): += , -= , *= , /= , %= . konstruktor-tüüpi initsialiseerimine (C++ originaalkonstruktsioon) int arv(10); Seda tüüpi initsialiseerimist ei soovitata enam kasutada, sest parameetriteta funktsiooni deklareerimine on sellega väga sarnane: int arv();  // funktsiooni 'arv' deklaratsioon
int arv(0); // muutuja 'arv' definitsioon koos algväärtusega 0 ühtne ( uniform ) initsialiseerimine (alates C++ standardist 2011). Arvulise muutuja initsialiseerimise korral tühjade loogeliste sulgudega on muutuja vaikeväärtuseks 0 . Järgmises näites muutuja arv1 väärtuseks on 0 . int arv{10};
long arv1{}; Soovituslik on kasutada seda initsialiseerimisviisi nii palju kui võimalik. Edaspidi püüame sellest kinni pidada. Muutuja nimeks kasutame tähega algavat tähtedest ja numbritest koosnevat sõnet, mis võib sisaldada ka alakriipsu _ . Muutuja nimeks ei tohi olla C++ võtmesõna, vt https://en.cppreference.com/w/cpp/keyword Täpsem definitsioon on aadressil https://en.cppreference.com/w/cpp/language/identifiers NB! C++ on tõstutundlik , nt muutujad arv ja Arv on erinevad muutujad. Kuidas valida identifikaatorite (muutujate, funktsioonide, klasside jne) nimesid, selleks on mitmeid soovitusi, nt Cppreference (alajaotus Code formatting): https://en.cppreference.com/w/Help:Manual_of_style Google C++ Style Guide https://google.github.io/styleguide/cppguide.html Üldised soovitused ja graafiliste keskkondade stiilid https://lefticus.gitbooks.io/cpp-best-practices/content/03-Style.html Muutujate nimede korral on valdav soovitus kasutada snake-case vormingut, kus nimi on väiketähtedega ja mitmest sõnast koosnevas nimes eraldatakse nimed alakriipsuga, nt int kasside_arv{};  // snake_case NB! Muutuja nimi peab olema tähendusega, st osundama hoitava informatsiooni sisule, vt Robert C. Martin, Clean Code, A Handbook of Agile Software Craftmanship, Prentice Hall, 2009  - kokkuvõte veebis: https://github.com/piloulac/clean-code/tree/master Andmetüübid Andmetüübid jagunevad fundamentaalsed ( fundamental ) liittüübid ( compound ) Selles peatükis vaatleme ainult fundamentaal- ehk lihttüüpe, liittüüpe ja tüüpi nullptr käsitleme hiljem.  
Tüübi suurus baitides ja esituse täpsus varieerub sõltuvalt riistvarast ja operatsioonisüsteemist.
Lihttüüpidest annab osalise ülevaate järgmine tabel (kaldkirjas võtmesõnad on lubatud ära jätta). Täpsem info on aadressil https://en.cppreference.com/w/cpp/language/types Tüübigrupp Tüüp Tüüpiline suurus baitides Esitusvahemik/täpsus Märgitüübid char üks bait -128 - 127 char8_t üks bait UTF-8 märk char16_t vähemalt 2 baiti Unicode 16 märk char32_t vähemalt 4 baiti Unicode 32 märk wchar_t vähemalt 2 baiti suvaline märk ( wide character ) Täisarvutüübid (märgiga) signed char vähemalt 1 bait -128 - 127 signed short int vähemalt 2 baiti -32768 - 32767 signed int vähemalt 2 baiti -2147483648 - 2147483647 signed long int vähemalt 4 baiti -9223372036854775808 - 9223372036854775807 signed long long int vähemalt 8 baiti -(2^63) - (2^63)-1 Täisarvutüübid (märgita) unsigned char 1 bait 0 - 255 unsigned short int 2 baiti 0 - 65535 unsigned int 4 baiti 0 - 4294967295 unsigned long int 8 baiti 0 - 18446744073709551615 unsigned long long int 8 baiti 0 - 18446744073709551615 Ujukomaarvu tüübid float 4 baiti 6 tüvikohta double 8 baiti 10 tüvikohta long double 12 baiti 10 tüvikohta Tõeväärtustüüp bool void tüüp void 0 baiti Täisarvud on vaikimisi märgiga. Kui on vaja ainult mittenegatiivseid täisarve, tuleb lisada tüübitäpsustus unsigned . Näiteks märgita kahebaidise täisarvu väärtusvahemik on 0 kuni 65535. Piiritlejad short ja long määravad täisarvu baitide arvuks vastavalt 2 või 4 baiti (vähemalt, sest täpne baitide arv sõltub kompilaatorist). Operaator sizeof annab tüübi või muutuja suuruse baitides: short sh{-345};
unsigned long long ull{345};
cout << "Tüübi 'short' suurus on " << sizeof(short) << " baiti.\n";
cout << "Muutuja  'ull' suurus on " << sizeof(ull) << " baiti.\n"; Tüübi 'short' suurus on 2 baiti.
Muutuja  'ull' suurus on 8 baiti. NB! Näiteks järgmine rida unsigned int ui{-5}; //kompileerimisviga annab kompileerimisvea, sest märgita täisarvutüüpi muutujale püütakse omistada negatiivset arvu. Tõeväärtustüübil bool on kaks väärtust: true ja false . Tegelikult esitatakse tõeväärtust täisarvuna; täisarv 0 (null) esitab tõeväärtust false ja kõik ülejäänud täisarvud esitavad tõeväärtust true (vaikimisi 1). bool ilus_ilm{true};
cout << "Täna on ilus ilm: " << ilus_ilm << "\n";
cout << boolalpha << "Täna on ilus ilm: " << ilus_ilm << "\n"; Täna on ilus ilm: 1
Täna on ilus ilm: true Käsuga boolalpha antakse väljundisse korraldus väljastada tõeväärtused võtmesõnadega true ja false . Tüüp void tähistab tüübi puudumist, kasutatakse näiteks funktsiooni nime ees. Selle kasutamist vaatame järgmises peatükis. Märkus: char tüübi puhul tasub arvestada, et väljastusel kirjutatakse ekraanile vastav tähemärk, mitte arv. Näiteks char x{65}; cout << x; tulemusena väljastatakse tähemärk 'A' . Kui on vaja tähemärgi koodi, siis saab kasutada teisendust static_cast<int> . char märk{65} ; // ASCII kood 'A' jaoks
cout << "Tähemärk : " << märk << "\n";
cout << "Tähemärgi kood (int) : " << static_cast<int>(märk) << "\n"; Tähemärk : A
Tähemärgi kood (int) : 65 Märgime siin, et keeles C++ ümbritsetakse char tüüpi literaal ülakomadega ( '' ), seevastu sõneliteraal ümbritsetakse jutumärkidega ( "" ). Avaldised Aritmeetiliste operaatoritega (tehetega) keeles C++ saab tutvuda aadressil https://en.cppreference.com/w/cpp/language/expressions Peatume siin vaid täisarvude jagamisel ja jagamise jäägil int arv1{2};
int arv2{7};
int tulemus;
tulemus = arv2 / arv1;
cout << "7/2 =  " << tulemus << "\n";
tulemus = arv2 % arv1;
cout << "7%2 =  " << tulemus << "\n"; 7/2 =  3
7%2 =  1 Kui soovime teostada täpset jagamist, st saada tulemuseks ujukomaarvu, siis peab vähemalt üks operandidest olema ujukomaarvu tüüpi: int arv1{2};
float arv2{7};
cout << "7/2 =  " << arv2 / arv1 << "\n"; 7/2 =  3.5 Keeles C++ on defineeritud ka operaatorid ++ ( increment ) ja -- ( decrement ). Need operaatorid kas suurendavad ( ++ ) või vähendavad -- muutujat ühe võrra. Kui operaator on muutuja ees ( pre-increment või pre-decrement ), siis avaldise arvutamisel kasutatakse muutuja uut väärtust. Kui operaator on muutuja järel ( post-increment või post-decrement ), siis avaldise arvutamisel kasutatakse muutuja vana väärtust ja muutuja saab uue väärtuse peale käsu täitmist. Vaatame näidet: int value{5};
cout << "Väärtust suurendatakse (post-increment) : " << value++ << "\n";
cout << "Uus väärtus : " << value << "\n";
value = 5;
cout << "Väärtust suurendatakse (pre-increment): "  << ++value << "\n";
cout << "Uus väärtus : " << value << "\n"; Väärtust suurendatakse (post-increment) : 5
Uus väärtus : 6
Väärtust suurendatakse (pre-increment): 6
Uus väärtus : 6 Tüübiteisendused Aritmeetilistes avaldistes on soovitatav kasutada sama tüüpi muutujaid. Kui siiski kasutatakse eri tüüpi muutujaid (või literaale, neist hiljem), siis kompilaator leiab avaldise tüübi avaldises esineva kõige 'suurema' tüübi järgi, kasutades selleks kindlaid reegleid. Reeglitega saab tutvuda lehel https://en.cppreference.com/w/cpp/language/implicit_conversion . Näiteks signed char või signed short saab teisendada tüübiks int unsigned char või unsigned short saab teisendada tüübiks int ,  kui int suudab mahutada kogu  esitusvahemiku, vastasel juhul teisendatakse tüübiks unsigned int . Toome siin tüüpide hierarhia alates tüübist int . Kompilaator püüab teisendada hierarhias alates 'väiksemast' esimeseks võimalikuks tüübiks. Mõned näited automaatsetest teisendustest: Kui bool tüüpi muutujale omistada mingi teist tüüpi arvuline väärtus, siis tulemuseks on false , kui omistatav on 0 ja true , kui omistatav on nullist erinev. Kui omistada bool tüüpi väärtus arvulisele tüübile, siis tulemuseks on 1 , kui bool väärtus on true ja 0 vastupidisel juhul. Kui omistada ujukomaarv täisarvu tüüpi muutujale, siis tulemuseks on ujukomaarvu täisosa. Kui omistada negatiivne väärtus märgita unsigned arvule, siis tulemus on ettearvamatu. int i{-2};
bool b = i; // true
cout << "b = " << boolalpha << b << '\n';
double d{-3.5}, d1{-5.2};
i = d; // -3
cout << "i = " << i << '\n';
d = b; // 1
cout << "d = " << d << '\n';
unsigned int ui = d1;
cout << "ui = " << ui << '\n'; b = true
i = -3
d = 1
ui = 4294967291 Võtmesõna auto - kohatäide ( placeholder ) Alates C++11 on keeles võimalus, et kompilaator ise tuvastab muutuja tüübi. Selleks võib muutuja defineerimisel tüübi asemel kirjutada võtmesõna auto . Järgmises näites operaator sizeof tagastab muutuja või literaali poolt hõivatava baitide arvu mälus. auto b{true}; //b on boolean
auto ch{'a'}; //ch on char
auto y{1.23}; //y on double
int täisarv{3};
float ujukomaarv{5.2};
auto x{täisarv + ujukomaarv}; // x on float
cout << sizeof(x) << '\n'; // 4
cout << sizeof(5.2 + 3) << '\n'; // 8 4
8 Arvulise tüübi asemel võib kasutada auto , kui ei ole vaja täpselt defineerida muutuja esitusvahemikku (nt täisarvutüüpide korral unsigned int vs int ). Kohatäite auto kasutusvaldkond ei piirdu arvuliste tüüpidega, vt https://en.cppreference.com/w/cpp/language/auto . Arvuliste väärtuste omistamisel saab väärtusele lisada sufiksi, mis määrab tüübi. Näiteks L lisamisel on arv long tüüpi. Sufiksitest annab ülevaate järgmine tabel: Andmetüüp Näited int 123 -25 long int 25000L -4444L unsigned int 1000U 888U float 123.123F -0.5678e-5F double 123.123 -0.1234 long double 123.123L -0.1234L Kaheksand- ja kuueteistkümnendsüsteemi arvude esitamisel kasutatakse prefikseid 0 ja 0x : int oct{015}; 
int hex{0x3AF}; Täpsemalt saab uurida aadressidel https://en.cppreference.com/w/cpp/language/integer_literal https://en.cppreference.com/w/cpp/language/floating_literal Bitikaupa operaatorid Bitikaupa operaatorid on lubatud int ja char (ja nende variatsioonid) tüüpi operandidega. 
C++ toetab järgmisi bitikaupa operaatoreid Operaator Tegevus Kasutamine & AND a&b | OR a|b ^ XOR a^b ~ NOT ~a >> Nihutamine paremale a>>b << Nihutamine vasakule a<<b Toome siin XOR ( ^ ) tõeväärtustabeli: p q p^q 0 0 0 1 0 1 1 1 0 0 1 1 Nagu tabelist näha, on tulemuseks 1 ( true ) siis, kui täpselt üks operandidest on 1 ( true ), vastasel juhul on tulemuseks 0 ( false ). Bitikaupa AND saab kasutada biti (bittide) nullimiseks, aga bitikaupa OR saab kasutada biti (bittide) seadmiseks (väärtuseks 1 ). Bitikaupa operaatorid >> ja << liigutavad etteantud arvu kohti kõiki bitte paremale või vasakule. 
Paremale nihutamise üldkuju: väärtus >> bittide arv Vasakule nihutamise üldkuju: väärtus << bittide arv Bittide nihutamisel ühest otsast välja lisatakse teise otsa nullid. Negatiivse täisarvu korral märgibitt säilib. Järgmises tabelis iga järgmine rida sõltub eelmisest. NB! Vasakule nihutamine ühe biti võrra korrutab kahega. Kui bitt sisuga 1 nihutatakse üle otsa, siis toimub informatsiooni kadu (tabeli neljandal real järjekordne vasakule nihutamine x=x<<1 ). Paremale nihutamine ühe biti võrra jagab kahega. Siin informatsiooni kadu ei toimu. Operaatorit << kasutatakse keeles C++ ka teises tähenduses: käsus cout kasutatakse operaatorit << andmete väljundisse saatmiseks. Võtmesõna const Muutujaid, mille nime ees const , ei saa programmi töö käigus muuta. Sellise muutuja defineerimisel tuleb see ka algväärtustada kas ilmutatult või riistvaraliste vahendite abil. const int a{10}; Kompilaator saab paigutada sellise muutuja paigutada ROM mälutsooni. Standardsisend ( cin ) ja standardväljund ( cout ) Standardsisendvooks ( cin ) on vaikimisi klaviatuur ja standardväljundvooks ( cout ) on ekraan. Standardsisendvoost cin lugemiseks kasutatakse operaatorit >> . Järgmise programmi käivitamisel
kasutaja sisestab klaviatuurilt 23 ja vajutab ENTER ): #include <iostream>
using namespace std;
int main (){
  int arv;
  cout << "Palun sisesta täisarv:";
  cin >> arv; // kasutaja sisestatud arv muutujasse arv
  cout << "Sisestatud arv on " << arv;
  cout << " ja selle ruut on " << arv*arv << ".\n";
  return 0;
} Palun sisesta täisarv:23
Sisestatud arv on 23 ja selle ruut on 529. Sisestada saab ka mitu andmeühikut, eraldades neid tühikuga: float pikkus, laius, kõrgus;
cout << "Palun sisesta risttahuka pikkus, laius ja kõrgus:";
cin >> pikkus >> laius >> kõrgus;
cout << "Risttahuka ruumala on " << pikkus*laius*kõrgus << ".\n"; Palun sisesta risttahuka pikkus, laius ja kõrgus:2.1 3.2 4.3
Risttahuka ruumala on 28.896. Enesetestid NB! Enesetestides eeldame, et on kasutatud standardnimeruumi ( using namespace std; ) << Näita enesetesti >> Your browser does not support including other html pages << Näita enesetesti >> Your browser does not support including other html pages << Näita enesetesti >> Your browser does not support including other html pages << Näita enesetesti >> Your browser does not support including other html pages << Näita enesetesti >> Your browser does not support including other html pages << Näita enesetesti >> Your browser does not support including other html pages << Näita enesetesti >> Your browser does not support including other html pages << Näita enesetesti >> Your browser does not support including other html pages Arvutiteaduse instituut Loodus- ja täppisteaduste valdkond Tartu Ülikool Tehniliste probleemide või küsimuste korral kirjuta: Kursuse sisu ja korralduslike küsimustega pöörduge kursuse korraldajate poole. Õppematerjalide varalised autoriõigused kuuluvad Tartu Ülikoolile. Õppematerjalide kasutamine on lubatud autoriõiguse seaduses ettenähtud teose vaba kasutamise eesmärkidel ja tingimustel. Õppematerjalide kasutamisel on kasutaja kohustatud viitama õppematerjalide autorile. Õppematerjalide kasutamine muudel eesmärkidel on lubatud ainult Tartu Ülikooli eelneval kirjalikul nõusolekul. Courses’i keskkonna kasutustingimused