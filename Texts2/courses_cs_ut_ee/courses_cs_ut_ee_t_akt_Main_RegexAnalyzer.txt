Automaadid, keeled ja translaatorid - Kursused - Arvutiteaduse instituut Esileht Automaadid, keeled ja translaatorid EN Logi sisse Automaadid, keeled ja translaatorid Üldinfo Ajakava Eksami näidised Teemad 1. Soojendus 2. Regulaaravaldised 3. Automaadid 4. Avaldise struktuur Avaldispuu läbimine Eksami alusosa! Regulaaravaldiste analüüs Raskemad harjutused* Isabelle* Kodutöö 5. Grammatikad ja lekser 6. Käsitsi parsimine 7. ANTLRiga töötamine 8. Interpretaator 9. Kompilaator 10. Edasi! Süvendus GitHub Moodle Zulip Zoom Regulaaravaldiste analüüs Teemat tutvustav video: RegexAnalyzer ja Grep-i algus . Regulaaravaldise puu klassid Regulaaravaldise süntaksipuu on moodustatud paketis week4.regex.ast oleva RegexNode klassi alamklasside isenditest. Konkreetsemalt, huvipakkuvad klassid on: Alternation – valik kahe alternatiivi ( getLeft() ja getRight() ) vahel Concatenation – kahe regulaaravaldise ( getLeft() ja getRight() ) konkatenatsioon Repetion – regulaaravaldise ( getChild() ) kordamine 0 või enam korda Letter – kindla tähega ( getSymbol() ) sobituv regulaaravaldis Epsilon – tühja sõne tähistav regulaaravaldis Nende läbimiseks on jällegi olemas RegexVisitor. Regulaaravaldiste analüsaator Enne kodutöö lahendamist oleks hea regulaaravaldise süntaksipuu peal ülesandeid lahendada. Vaatame klassi RegexAnalyzer , mis tuleb täiendada. Vaja on implementeerida kolm meetodit, mis võtavad argumendiks regulaaravaldise süntaksipuu ja analüüsivad selle. matchesEmptyWord kontrollib, kas tühisõne kuulub selle regulaaravaldise poolt defineeritud keelde. getFirst tagastab regulaaravaldise põhjal kõik tähed, millega regulaaravaldisele vastav keel võib alata. Näiteks "(a|b)*cd" puhul on esimesed tähed 'a', 'b' ja 'c'. Selleks on väga abiks eelmine funktsioon, sest konkatenatsiooni puhul peab jälgima, kas esimene osa võib olla tühi või mitte. getAllWords tagastab lõpliku keele korral hulga kõigi selle regulaaravaldisega sobivate sõnadega. Lõpmatu keele korral tuleb visata erind. getAllWords: abimeetod combine Alamülesandena soovitame realiseerida meetodi combine , mis võtab kaks sõnede hulka ja tagastab uue sõnede hulga, mis sisaldab kõiki esimese ja teise hulga sõnede kombinatsioone, nii et esimese hulga sõne on konkateneeritud teise hulga sõnega. Näide pseudokoodis: RegexAnalyzer.combine({"kala", "äri"},  {"mees", "naine", ""}) peaks tagastama {"kalamees", "kalanaine", "kala", "ärimees", "ärinaine", "äri"} matchesEmptyWord ja getFirst korraga Kui oled matchesEmptyWord ja getFirst implementeerinud eraldi, siis proovi getFirst arvutada niimoodi, et ei peaks kogu aeg uuesti arvutama, kas alampuu võib olla tühi. Kuna me esimese meetodi vahetulemusi ei salvestata, siis võib teda kutsuda välja mitu korda. Siin aines me üldiselt ei muretse efektiivsuse pärast, aga oluline on aru saada, kus võib halvasti minna. Siin on asi tõsine! Esimene meetod arvutab ju ka oma lapsi iga kord uuesti, et koos võivad need meetodid külastada sügavusel d tipu äärmisel juhul d 2 korda. Proovi implementeerida need kaks meetodit korraga. Selleks on siis vaja tagastada kahte väärtust korraga ja Java nõuab selleks oma klassi loomist. See on hea harjutus, sest kodutöös pead ka oma tulemustüübi looma. Arvutiteaduse instituut Loodus- ja täppisteaduste valdkond Tartu Ülikool Tehniliste probleemide või küsimuste korral kirjuta: Kursuse sisu ja korralduslike küsimustega pöörduge kursuse korraldajate poole. Õppematerjalide varalised autoriõigused kuuluvad Tartu Ülikoolile. Õppematerjalide kasutamine on lubatud autoriõiguse seaduses ettenähtud teose vaba kasutamise eesmärkidel ja tingimustel. Õppematerjalide kasutamisel on kasutaja kohustatud viitama õppematerjalide autorile. Õppematerjalide kasutamine muudel eesmärkidel on lubatud ainult Tartu Ülikooli eelneval kirjalikul nõusolekul. Courses’i keskkonna kasutustingimused